#include <iostream>
#include <thread>
#include "Util/Timer.cpp"
#include "Contract/Coin.cpp"
#include "Graph/Lockfree/Graph.cpp"
#include "Util/FILEOPR.cpp"

#define MAX_THREADS 128
#define M_SharedObj 5000
#define FUN_IN_CONT 3
#define pl "=============================\n"

using namespace std;
using namespace std::chrono;

int    SObj    = 2;        //! SObj: number of shared objects; at least 2, to send & recive.
int    nThread = 1;        //! nThread: total number of concurrent threads; default is 1.
int    numAUs;             //! numAUs: total number of Atomic Unites to be executed.
double lemda;              //! Î»: random delay seed.
double tTime[2];           //! total time taken by miner and validator algorithm.
Coin   *coin;              //! smart contract.
Graph  *cGraph;            //! conflict grpah generated by miner to be given to validator.
int    *aCount;            //! aborted transaction count.
float_t*mTTime;            //! time taken by each miner Thread to execute AUs (Transactions).
float_t*vTTime;            //! time taken by each validator Thread to execute AUs (Transactions).
vector<string>listAUs;     //! holds AUs to be executed on smart contract: "listAUs" index+1 represents AU_ID.
std::atomic<int>currAU;    //! used by miner-thread to get index of Atomic Unit to execute.
std::atomic<int>gNodeCount;//! # of valid AU node added in graph (invalid AUs will not be part of the graph & conflict list).
std::atomic<int>eAUCount;  //! used by validator threads to keep track of how many valid AUs executed by validator threads.
std::atomic<int>*mAUT;     //! array to map AUs to Trans id (time stamp); mAUT[index] = TransID, index+1 = AU_ID.

/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    Class "Miner" CREATE & RUN "n" miner-THREAD CONCURRENTLY           !
!"concMiner()" CALLED BY miner-THREAD TO PERFROM oprs of RESPECTIVE AUs !
! THREAD 0 IS CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER)     !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Miner
{
	public:
	Miner(int minter_id)
	{
		//! init counter used to execute the numAUs to 0.
		//! init graph node counter to 0 (number of AUs 
		//! added in graph, invalid AUs are not part of the grpah).
		cGraph     = new Graph();
		currAU     = 0;
		gNodeCount = 0;
		mTTime     = new float_t [nThread];//! array index -> respective tid.
		aCount     = new int [nThread];
		for( int i = 0; i < nThread; i++ ) 
		{
			mTTime[i] = 0;
			aCount[i] = 0;
		}
		//! id of the contract creater is "minter_id".
		coin = new Coin(SObj, minter_id);
	}


	//!------------------------------------------------------------------------- 
	//!!!!!!!! MAIN MINER:: CREATE MINER + GRAPH CONSTRUCTION THREADS !!!!!!!!!!
	//!-------------------------------------------------------------------------
	void mainMiner()
	{
		Timer Ltimer;
		thread T[nThread];
		int ts, bal = 1000, total = 0;

		//! initialization of account with fixed ammount;
		//! mint() is assume to be serial.
//		cout<<pl<<"SHARED OBJECTS INITIAL STATE\n"
//			<<pl<<"SObj ID | INITIAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			//! 0 is contract deployer.
			while(coin->mint_m(0, sid, bal, &ts) == false)
			{
				aCount[0]++;
			}
//			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
			total = total + bal;
		}
//		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;

		//!-----------------------------------------------------------
		//!!!!!!!!!!    Create nThread Miner threads      !!!!!!!!!!
		//!-----------------------------------------------------------
//		cout<<"!!!!!!!   Lock-Free Miner Thread Started        !!!!!!\n";

		//! start timer.
		double start = Ltimer.timeReq();
		
		//! create "nThread" miner threads.
		for( int i = 0; i < nThread; i++ ) 
		{
			T[i] = thread(concMiner, i, numAUs, cGraph);
		}
		//! miner thread join.
		for( auto &th : T) 
		{
			th.join ( );
		}

		//! end timer to get time taken by miner algorithm.
		tTime[0] = Ltimer.timeReq() - start;

//		cout<<"!!!!!!!   Lock-Free Miner Thread Join           !!!!!!\n";
//		cGraph->print_grpah(); //! print conflict grpah generated by miner.
//		FILEOPR file_opr;
//		file_opr.pAUTrns(mAUT, numAUs); //! print AU_ID and Timestamp.
//		finalState(); //! print the final state of the shared objects.
	}


	//!--------------------------------------------------------
	//! The function to be executed by all the miner threads. !
	//!--------------------------------------------------------
	static void concMiner( int t_ID, int numAUs, Graph *cGraph)
	{
		//! flag is used to add valid AUs in Graph (invalid AU: 
		//! senders does't have sufficent balance to send).
		//! get the current index, and increment it.
		//! statrt clock to get time taken by this transaction.
		Timer Ttimer;
		bool flag   = true;
		int  curInd = currAU++;
		auto start  = Ttimer._timeStart();

		while(curInd < numAUs)
		{
			//!tid of STM_OSTM_transaction that successfully executed this AU.
			//! trans_ids with which this AU.trans_id is conflicting.
			//! get the AU to execute, which is of string type.
			int t_stamp;
			list<int>conf_list;
			istringstream ss(listAUs[curInd]);

			string tmp;
			ss >> tmp; //! AU_ID to Execute.

			int AU_ID = stoi(tmp);

			ss >> tmp; //! Function Name (smart contract).

			if(tmp.compare("get_bal") == 0)
			{
				ss >> tmp; //! get balance of SObj/id.
				int s_id = stoi(tmp);
				int bal  = 0;

				//! get_bal() of smart contract.
				bool v = coin->get_bal_m(s_id, &bal, t_ID, &t_stamp, conf_list);
				while(v == false) //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->get_bal_m(s_id, &bal, t_ID, &t_stamp, conf_list);
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			if(tmp.compare("send") == 0)
			{
				ss >> tmp; //! Sender ID.
				int s_id  = stoi(tmp);
				
				ss >> tmp; //! Reciver ID.
				int r_id  = stoi(tmp);

				ss >> tmp; //! Ammount to send.
				int amt   = stoi(tmp);
				
				int v = coin->send_m(t_ID, s_id, r_id, amt, &t_stamp, conf_list);
				while(v != 1 ) //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->send_m(t_ID, s_id, r_id, amt, &t_stamp, conf_list);
					if(v == -1)
					{
						//! invalid AU: sender does't 
						//! have sufficent balance to send.
						flag = false;
						break;                                  
					}
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			//! graph construction for committed AUs.
			if (flag == true)
			{
				//! increase graph node counter (Valid AU executed).
				gNodeCount++;

				//! IMP::delete time stamps in conflict list, which are added
				//! because of initilization of SObj by mnit() trycommit.
				for(int y = 0; y <= 2*SObj; y++) conf_list.remove(y);
				
				string st = "\nAU ["+ to_string(AU_ID)+"] TS ["+to_string(mAUT[AU_ID-1])+"] Conflict List {"; 
				for(auto it = conf_list.begin(); it!= conf_list.end(); it++)
					st = st+" " + to_string(*it);
//				cout<<st+"}\n";
				
				//!------------------------------------------
				//! conf_list come from contract fun using  !
				//! pass by argument of get_bel() and send()!
				//!------------------------------------------
				if(conf_list.begin() == conf_list.end())//!when list is empty.
				{
					Graph:: Graph_Node *tempRef;
					cGraph->add_node(AU_ID, t_stamp, &tempRef);
				}

				for(auto it = conf_list.begin(); it != conf_list.end(); it++)
				{
					int i = 0;
					//! find the conf_AU_ID in map table
					//! given conflicting time-stamp.
					while(*it != mAUT[i])
						i = (i+1)%numAUs; 

					//! because array index start with 0
					//! and index+1 respresent AU_ID.
					int cAUID   = i+1;
					
					//! conflicting AU_ID with this.AU_ID.
					int cTstamp = mAUT[i];
					
					//! edge from conf_AU_ID to AU_ID.
					if(cTstamp  < t_stamp)
						cGraph->add_edge(cAUID, AU_ID, cTstamp, t_stamp);
					
					//! edge from AU_ID to conf_AU_ID.
					if(cTstamp > t_stamp)
						cGraph->add_edge(AU_ID, cAUID, t_stamp, cTstamp);
				}
			}
			//! reset flag for next AU.
			//! get the current index to execute, and increment it.
			flag   = true;
			curInd = currAU++;
//			cGraph->print_grpah();
		}
		mTTime[t_ID] = mTTime[t_ID] + Ttimer._timeStop( start );
	}

	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. we are geting this using get_bel()|
	//!-------------------------------------------------
	void finalState()
	{
		list<int>cList;	int total = 0;
		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
			<<pl<<"SObj ID | FINAL STATE\n"<<pl;

		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0, ts;
			//! get_bal() of smart contract, execute again if tryCommit fails.
			while(coin->get_bal_m(sid, &bal, 0, &ts, cList)==false) {
			}
			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
			total = total + bal;
		}
		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
//		cout<<"\n Number of Valid   AUs = "+to_string(gNodeCount)
//				+" (Grpah Nodes:: AUs Executed Successfully)\n";
//		cout<<" Number of Invalid AUs = "+to_string(numAUs-gNodeCount)+"\n";
	}
	~Miner() { };
};



/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Class "Validator" CREATE & RUN "n" validator-THREAD CONCURRENTLY BASED ON CONFLICT GRPAH!
! GIVEN BY MINER. "concValidator()" CALLED BY validator-THREAD TO PERFROM OPERATIONS of   !
! RESPECTIVE AUs. THREAD 0 IS CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER)       !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Validator
{
public:
	Validator()
	{
		//! array index location represents respective thread id.
		eAUCount = 0;
		vTTime   = new float_t[nThread];
		for(int i = 0; i < nThread; i++)
			vTTime[i] = 0;
	};

	/*!-------------------------------------------------------------------------
	| create n concurrent validator threads to execute valid AUs in conf graph |
	--------------------------------------------------------------------------*/
	void mainValidator()
	{
		Timer Ttimer;
		int bal = 1000, total = 0;
		thread T[nThread];
		//! initialization of account with fixed ammount;
		//! mint_val() function is assume to be serial.
		for(int sid = 1; sid <= SObj; sid++) 
		{
			bool r = coin->mint(0, sid, bal); //! 0 is contract deployer.
			total  = total + bal;
		}

		//!Create "nThread" threads
		double start = Ttimer.timeReq();                //! start timer.
		for(int i = 0; i < nThread; i++)
			T[i] = thread(concValidator, i);

		for(auto& th : T) th.join ( );
		tTime[1] = Ttimer.timeReq() - start; //! stop timer

//		finalState(); //! print the final state of the SObjs by validator.
	}

	//!--------------------------------------------------------
	//! The function to be executed by all Validator threads. !
	//!--------------------------------------------------------
	static void concValidator( int t_ID )
	{
		Timer Ttimer;
		//! start timer to get time taken by this thread.
		auto start = Ttimer._timeStart();
		list<Graph::Graph_Node*>buffer;
		auto itr = buffer.begin();
		Graph:: Graph_Node *verTemp;
		while( true )
		{
			//!uncomment this to remove the effect of local buffer optimization.
//			buffer.clear();

			if(eAUCount == gNodeCount) //! all Graph Nodes (Valid AUs executed).
				break;

			//!------------------------------------------
			//!!!<< AU execution from local buffer. >>!!!
			//!------------------------------------------
			for(itr = buffer.begin(); itr != buffer.end(); itr++)
			{
				Graph::Graph_Node* temp = *itr;
				if(temp->in_count == 0)
				{
					//! expected in_degree is 0 then vertex can be
					//! executed if not claimed by other thread.
					int expected = 0;
					if(atomic_compare_exchange_strong( &(temp->in_count), &expected, -1 ) == true)
					{
						eAUCount++; //! num of Valid AUs executed is eAUCount+1

						//! get the AU to execute, which is of 
						//! string type; listAUs index statrt with 0
						istringstream ss(listAUs[(temp->AU_ID)-1]);
						string tmp;

						ss >> tmp; //! AU_ID to Execute.
						int AU_ID = stoi(tmp);

						ss >> tmp; //! Function Name (smart contract).
						if(tmp.compare("get_bal") == 0)
						{
							ss >> tmp; //! get balance of SObj/id.
							int s_id = stoi(tmp);
							int bal  = 0;

							//! get_bal() of smart contract.
							bool v = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							ss >> tmp; //! Sender ID.
							int s_id = stoi(tmp);
							ss >> tmp; //! Reciver ID.
							int r_id = stoi(tmp);
							ss >> tmp; //! Ammount to send.
							int amt  = stoi(tmp);
							bool v   = coin->send(s_id, r_id, amt);
						}
						
						//!-----------------------------------------
						//!change indegree of out edge nodes (node !
						//! having incomming edge from this node). !
						//!-----------------------------------------						
						Graph::EdgeNode *e_temp = temp->edgeHead->next;
						while( e_temp != temp->edgeTail)
						{
							Graph::Graph_Node* refVN = 
										(Graph::Graph_Node*)e_temp->ref;
							refVN->in_count--;

							if(refVN->in_count == 0 )
							//! insert into local buffer.
								buffer.push_back(refVN);

							e_temp = e_temp->next;
						}
					}
				}
			}
			buffer.clear();//! reached to end of local buffer; clear the buffer.

			//!-----------------------------------------------------
			//!!!<< AU execution by traversing conflict grpah  >>!!!
			//!-----------------------------------------------------
			verTemp = cGraph->verHead->next;
			while(verTemp != cGraph->verTail)
			{
				if(verTemp->in_count == 0)
				{
					//! expected in_degree is 0 then vertex can be
					//! executed if not claimed by other thread
					int expected = 0;
					if(atomic_compare_exchange_strong( &(verTemp->in_count), &expected, -1 ) == true)
					{
						eAUCount++; //! num of Valid AUs executed is eAUCount+1

						//get the AU to execute, which is of string
						//type; listAUs index statrt with 0
						istringstream ss( listAUs[(verTemp->AU_ID) -1 ]);
						string tmp;
						ss >> tmp; //! AU_ID to Execute.
						int AU_ID = stoi(tmp);

						ss >> tmp; //! Function Name (smart contract).
						if(tmp.compare("get_bal") == 0)
						{
							ss >> tmp; //! get balance of SObj/id.
							int s_id = stoi(tmp);
							int bal  = 0;

							//! get_bal() of smart contract.
							bool v = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							ss >> tmp; //! Sender ID.
							int s_id = stoi(tmp);
							ss >> tmp; //! Reciver ID.
							int r_id = stoi(tmp);
							ss >> tmp; //! Ammount to send.
							int amt  = stoi(tmp);
							bool v   = coin->send(s_id, r_id, amt);
						}
						
						//!-----------------------------------------
						//!change indegree of out edge nodes (node !
						//! having incomming edge from this node). !
						//!-----------------------------------------
						Graph::EdgeNode *e_temp = verTemp->edgeHead->next;

						while(e_temp != verTemp->edgeTail)
						{
							Graph::Graph_Node* refVN = 
											(Graph::Graph_Node*)e_temp->ref;
							refVN->in_count--;
							//! insert into local buffer.
							if(refVN->in_count == 0 )
								buffer.push_back(refVN);
							e_temp = e_temp->next;
						}
					}
				}
				verTemp = verTemp->next;
			}
		}
		//!stop timer to get time taken by this thread.
		vTTime[t_ID] = vTTime[t_ID] + Ttimer._timeStop( start );
	}


	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. Geting this using get_bel_val()   |
	//!-------------------------------------------------
	void finalState()
	{
		int total = 0;
		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
			<<pl<<"SObj ID | FINAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0, ts;
			bool v  = coin->get_bal(sid, &bal);
			total   = total + bal;
			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
		}
		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
	}

	~Validator() { };
};



/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!          main()         !!!!!!!!!!*/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
int main( )
{

	//! list holds the avg time taken by miner and Validator
	//! thread s for multiple consecutive runs.
	list<double>mItrT;
	list<double>vItrT;
	//! to get total number of dependencies in graph;
	int totalDepInG = 0;

	FILEOPR file_opr;

	//! read from input file:: SObj = #SObj; nThread = #threads;
	//! numAUs = #AUs; Î» = random delay seed.
	file_opr.getInp(&SObj, &nThread, &numAUs, &lemda);
	//! max shared object error handling.
	if(SObj > M_SharedObj) 
	{
		SObj = M_SharedObj;
		cout<<"Max number of Shared Object can be "<<M_SharedObj<<"\n";
	}

	cout<<pl<<"MVOSTM Lock Free Decentralized Algorithm \n"<<pl;
	int totalRun = 6;
	for(int numItr = 0; numItr < totalRun; numItr++)
	{
		 //! generates AUs (i.e. trans to be executed by miner & validator).
		file_opr.genAUs(numAUs, SObj, FUN_IN_CONT, listAUs);

		//! index+1 represents respective AU id, and
		//! mAUT[index] represents "time stamp (commited trans)".
		mAUT = new std::atomic<int>[numAUs];
		for(int i = 0; i< numAUs; i++)
		{
			mAUT[i] = 0;
		}
		Timer mTimer;
		mTimer.start();

		//MINER
		Miner *miner = new Miner(0);
		miner ->mainMiner();

		if(numItr > 0)//skip first run
		totalDepInG += cGraph->print_grpah();//give dependenices in the graph.

		//VALIDATOR
		Validator *validator = new Validator();
		validator ->mainValidator();

		mTimer.stop();

		//total valid AUs among total AUs executed
		// by miner and varified by Validator.
		int vAUs = gNodeCount;
		if(numItr > 0)//skip first run
		file_opr.writeOpt(SObj, nThread, numAUs, tTime, mTTime,
									vTTime, aCount, vAUs, mItrT, vItrT);
//		cout<<"\n===================== Execution "<<numItr+1
//			<<" Over =====================\n"<<endl;

		listAUs.clear();
		free(miner);
		miner = NULL;
		free(cGraph);
		cGraph = NULL;
		free(validator);
		validator = NULL;
	}
	
	//to get total avg miner and validator
	//time after number of totalRun runs.
	double tAvgMinerT = 0, tAvgValidT = 0;
	auto mit = mItrT.begin();
	auto vit = vItrT.begin();
	for(int j = 1; j < totalRun; j++)
	{
		tAvgMinerT = tAvgMinerT + *mit;
//		cout<<"\n    Avg Miner = "<<*mit;
		tAvgValidT = tAvgValidT + *vit;
//		cout<<"\nAvg Validator = "<<*vit;
		mit++;
		vit++;
	}
	tAvgMinerT = tAvgMinerT/(totalRun-1);
	tAvgValidT = tAvgValidT/(totalRun-1);
	cout<<pl<<"    Total Avg Miner       = "<<tAvgMinerT<<" microseconds";
	cout<<"\nTotal Avg Validator       = "<<tAvgValidT<<" microseconds";
	cout<<"\nAvg Dependencies in Graph = "<<totalDepInG/(totalRun-1);
//	cout<<"\n  Total Avg (M + V) = "<<tAvgMinerT+tAvgValidT<<" microseconds";
	cout<<"\n"<<pl;

	mItrT.clear();
	vItrT.clear();

	delete mTTime;
	delete vTTime;
	delete aCount;

return 0;
}
